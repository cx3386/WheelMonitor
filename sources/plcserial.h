#pragma once
#include <QObject>
#include "common.h"

class ConfigHelper;
class QSerialPort;

class PLCSerial : public QObject
{
	Q_OBJECT
public:
	explicit PLCSerial(const ConfigHelper *_configHelper, QObject *parent = nullptr);
	~PLCSerial();

	inline double getTrolleySpeed(int deviceIndex)
	{
		QMutexLocker locker(&mutex);
		return trolleySpeed * speedCompensationCoeff[deviceIndex];
	}
	inline double isConnect()
	{
		QMutexLocker locker(&mutex);
		return bIsConnect;
	}
	//enum AlarmColor
	//{
	//	AlarmColorGreen,
	//	AlarmColorRed,
	//	AlarmColorYellow,
	//	AlarmOFF,
	//};

private:
	const ConfigHelper *configHelper;
	QMutex mutex;
	QSerialPort *plcSerialPort;
	double trolleySpeed; //linear Velocity read from AD, unit:m/min

	// bool sensorRight = false; //out
	// bool sensorLeft = false;  //in
	bool sol = false; ///< sensor out left 左侧进入
	bool sor = false; ///< sensor out right 右侧离开
	bool sil = false; ///< sensor in left 左侧离开
	bool sir = false; ///< sensor in right 右侧进入
	// for unsigned type like word, >> is logic move right.
	// for signed type like int, >> is arithmetic move right
	WORD cio0 = 0;	 ///< cio0 used0.1~0.8
	bool sol0 = false;
	bool sol1 = false;
	bool sor0 = false;
	bool sor1 = false;
	bool sir0 = false;
	bool sir1 = false;
	bool sil0 = false;
	bool sil1 = false;
	bool stopSensor = false;
	bool bIsConnect = false;
	QTimer *sensorTimer;
	QTimer *trolleyTimer;
	/* one read write period >300ms */
	int sensorSamplingPeriod = 1000; // msec
	int trolleySamplingPeriod = 250; //msec; should > 7/25 s

	void writePLC(QByteArray plcData);
	QByteArray readPLC(QByteArray plcData);
	/**
	 * \brief return a FCS code generated by cmd code
	 * e.g., cmd = '@00RR00020001', fcs code = '0x43', the full code = "@00RR0002000143*\r"
	 *
	 * \param QByteArray cmd
	 */
	static QByteArray getFCSCode(QByteArray cmd);
	static inline QByteArray getFullCode(QByteArray cmd) { return cmd + getFCSCode(cmd) + "*\r"; }
	/**
	 * \brief generate a RR command code
	 * PC to PLC ask(command) code
	 * "@00RR0001(ADDR)0001(No. of words)FCS*\r"
	 * except data and end code is hex, the others is BCD.
	 *
	 * \param int addr (cio) register address of beginning word to read
	 * \param int num how many words to read
	 */
	static QByteArray genRRCode(int addr, int num);
	/**
	* \brief generate a WR command code
	* PC to PLC ask(command) code
	* "@00WR0100(ADDR)data(words,hex)FCS*\r"
	* except data and end code is hex, the others is BCD.
	*
	* \param int addr (cio) register address of beginning word to write
	* \param QByteArray data how many words to read or the data to write
	*/
	static QByteArray genWRCode(int addr, QByteArray data);

	/**
	 * \brief check answer code if it's right.
	 * PLC to PC answer(response) code:
	 * "@00RR00(endcode,hex)data(words,hex)FCS*\r"
	 * "@00WR00(endcode,hex)FCS*\r"
	 * except data and end code is hex, the others is BCD.
	 *
	 * \param QByteArray
	 */
	static bool checkAnsCode(QByteArray);
	/**
	 * \brief get RR data from response code
	 *
	 * \param QByteArray
	 */
	static QByteArrayList getRRData(QByteArray);

private slots:
	void readSensor();
	/**
	 * \brief read trolley reference speed from AD module
	 * a cycle includes sending cmd and recv response, costs ~ 300ms
	 */
	void readTrolley();

signals:
	void showCio2Ui(WORD);
	void _DZIn();
	void _DZOut();
	void trolleySpeedReady();
	/**
	 * \brief 台车(中轴)速度信号读取错误
	 * errcode 1: disconnect
	 * errcode 2: out of range(4~20ma)
	 * \param int errorCode
	 */
	void trolleySpeedError(int);

public slots:
	/**
	 * \brief initialize the connection to PLC and setup AD module
	 *
	 */
	void init();
	void onAlarmEvent(int);

	void startTimer(); // can't op timer through thread
	void stopTimer();
};