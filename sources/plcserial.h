#pragma once
#include <QObject>
#include "common.h"
#include "LevelRecorder.h"

class ConfigHelper;
class QSerialPort;

/*!
 * \class PLCSerial
 *
 * \brief
 *
 * \author cx3386
 * \date 十月 2018
 */
class PLCSerial : public QObject
{
	Q_OBJECT
public:
	//! 必须传入configure, const成员变量在初始化列表中初始化
	explicit PLCSerial(const ConfigHelper *_configHelper, QObject *parent = nullptr);
	~PLCSerial();
	// 用于mainwindow跨线程控制
	void start() { QTimer::singleShot(0, this, &PLCSerial::onStart); }
	void stop() { QTimer::singleShot(0, this, &PLCSerial::onStop); }
	void init() { QTimer::singleShot(0, this, &PLCSerial::onInit); }
	inline double getTruckSpeed(int deviceIndex)
	{
		QMutexLocker locker(&mutex);
		return truckSpeed * speedCompensationCoeff[deviceIndex];
	}
	inline double isConnect()
	{
		QMutexLocker locker(&mutex);
		return bIsConnect;
	}

private:
	const ConfigHelper *configHelper;
	QMutex mutex;
	QSerialPort *plcSerialPort;
	double truckSpeed; //linear Velocity read from AD, unit:m/min

	// bool sensorRight = false; //out
	// bool sensorLeft = false;  //in
	bool sol = false; ///< sensor out left 左侧进入
	bool sor = false; ///< sensor out right 右侧离开
	bool sil = false; ///< sensor in left 左侧离开
	bool sir = false; ///< sensor in right 右侧进入
	// for unsigned type like word, >> is logic move right.
	// for signed type like int, >> is arithmetic move right
	WORD cio0_pre = 0; //!< cio0的历史数据(used0.1~0.8)
	LevelRecorder sensorRecorders[8]; //!< 用于记录每个传感器的历史信息
											// 	 sol0 1
											// 	 sol1 2
											// 	 sor0 3
											// 	 sor1 4
											// 	 sir0 5
											// 	 sir1 6
											// 	 sil0 7
											//   sil1 8
											//   note: 0.0 is NC
	bool stopSensor = false;
	bool bIsConnect = false;
	QTimer *sensorTimer;
	QTimer *truckTimer;
	/* one read write period >300ms */
	int sensorSamplingPeriod = 1000; // msec
	int truckSamplingPeriod = 250; //msec; should > 7/25 s

	void writePLC(QByteArray plcData);
	QByteArray readPLC(QByteArray plcData);
	/**
	 * \brief return a FCS code generated by cmd code
	 * e.g., cmd = '@00RR00020001', fcs code = '0x43', the full code = "@00RR0002000143*\r"
	 *
	 * \param QByteArray cmd
	 */
	static QByteArray getFCSCode(QByteArray cmd);
	static inline QByteArray getFullCode(QByteArray cmd) { return cmd + getFCSCode(cmd) + "*\r"; }
	/**
	 * \brief generate a RR command code
	 * PC to PLC ask(command) code
	 * "@00RR0001(ADDR)0001(No. of words)FCS*\r"
	 * except data and end code is hex, the others is BCD.
	 *
	 * \param int addr (cio) register address of beginning word to read
	 * \param int num how many words to read
	 */
	static QByteArray genRRCode(int addr, int num);
	/**
	* \brief generate a WR command code
	* PC to PLC ask(command) code
	* "@00WR0100(ADDR)data(words,hex)FCS*\r"
	* except data and end code is hex, the others is BCD.
	*
	* \param int addr (cio) register address of beginning word to write
	* \param QByteArray data how many words to read or the data to write
	*/
	static QByteArray genWRCode(int addr, QByteArray data);

	/**
	 * \brief check answer code if it's right.
	 * PLC to PC answer(response) code:
	 * "@00RR00(endcode,hex)data(words,hex)FCS*\r"
	 * "@00WR00(endcode,hex)FCS*\r"
	 * except data and end code is hex, the others is BCD.
	 *
	 * \param QByteArray
	 */
	static bool checkAnsCode(QByteArray);
	/**
	 * \brief get RR data from response code
	 *
	 * \param QByteArray
	 */
	static QByteArrayList getRRData(QByteArray);

private slots:
	void readSensor();
	/**
	 * \brief read truck reference speed from AD module
	 * a cycle includes sending cmd and recv response, costs ~ 300ms
	 */
	void readTruck();
	//! 连接到PLC，初始化AD041。必须在子线程中执行（只一次）
	void onInit();
	//! 用于mainwindow的操控，开始循环读取AD041和CIO0的数据
	void onStart(); // can't op timer across threads
	//! 用于mainwindow的操控，停止循环读取AD041和CIO0的数据
	void onStop();  //!< 不会断开与plc的连接

signals:
	void showCio2Ui(WORD);
	void _DZIn(int id);  //!< 车轮进入DZ, id为deviceIndex
	void _DZOut(int id); //!< 车轮离开DZ, id为deviceIndex
	void truckSpeedReady();
	/**
	 * \brief 台车(中轴)速度信号读取错误
	 * errcode 1: disconnect
	 * errcode 2: out of range(4~20ma)
	 * \param int errorCode
	 */
	void truckSpeedError(int);

public slots:
	void onAlarmEvent(int);
};